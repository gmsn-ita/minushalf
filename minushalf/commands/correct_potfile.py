"""
Atomic Correct potential file
"""
from __future__ import annotations
import sys
import click
import numpy as np
from loguru import logger
from pathlib import Path
from minushalf.softwares import Vasp
from minushalf.atomic import Vtotal, InputFile
from minushalf.utils import welcome_message, end_message


@click.command()
@click.option('--quiet', default=False, is_flag=True)
@click.option('-p',
              '--potcar_path',
              type=click.Path(exists=True),
              default="POTCAR",
              show_default=True,
              help="""Path relative to the POTCAR file, an input
              to VASP program""")
@click.option('-v',
              '--vtotal_path',
              type=click.Path(exists=True),
              default="VTOTAL.ae",
              show_default=True,
              help="""Path relative to the pseudo potential
              file generated by the atomic program for the
              atom with all electrons.""")
@click.option('-o',
              '--vtotal_occupied_path',
              type=click.Path(exists=True),
              default="VTOTAL_OCC",
              show_default=True,
              help="""Path relative to the pseudo potential
              file generated by the atomic program for the
              occupied atom.""")
@click.option('-i',
              '--input_path',
              type=click.Path(exists=True),
              default="INP_OCC",
              show_default=True,
              help="""Path to the atomic program input
    file for the occupied atom""")
@click.option('-s',
              '--software',
              type=click.Choice(['VASP'], case_sensitive=False),
              default="VASP",
              show_default=True,
              help="""Specifies the software used to define the
              structure of the file containing the atoms potential.""")
@click.option('-c',
              '--correction',
              type=click.Choice(['VALENCE', 'CONDUCTION'],
                                case_sensitive=False),
              default="VALENCE",
              show_default=True,
              help="""Indicates whether the correction should be
                      made in the last valence band, the first conduction band or both."""
              )
@click.option('-C',
              '--cut',
              type=str,
              nargs=1,
              help="""
              distance value used to cut the potential generated artificially
              by fractional atomic occupation , it can be passed in two ways:

              unique value : float or integer

              \b
              range:  begin(float|integer):pass(float|integer):end(float|integer)

              """)
@click.option('-a',
              '--amplitude',
              type=click.FloatRange(0.0, 20.0),
              default=1.0,
              show_default=True,
              nargs=1,
              help="""Multiplying factor to be used to
              correct the artificially generated potential.""")
def correct_potfile(
    quiet: bool,
    potcar_path: str,
    vtotal_path: str,
    vtotal_occupied_path: str,
    input_path: str,
    software: str,
    correction: str,
    cut: str,
    amplitude: float,
) -> None:
    """Generate occupied atomic potential file used for ab initio calculations.

    Requires:

        VTOTAL.ae

        VTOTAL_OCC

        POTENTIAL_FILE(POTCAR)

        INP_OCC


    Generates:

        POTFILEcut${CUT_VALUE} (If amplitude is equal to 1.0)

        POTFILEcut${CUT_VALUE}A${AMP_VALUE} (If amplitude is different to 1.0)

    """
    welcome_message("minushalf")

    if quiet:
        logger.remove()
        logger.add(sys.stdout, level="ERROR")

    optional_params = {
        "vtotal": Vtotal.from_file(Path(vtotal_path).__str__()),
        "vtotal_occupied":
        Vtotal.from_file(Path(vtotal_occupied_path).__str__()),
        "input_file": InputFile.from_file(Path(input_path).__str__())
    }

    if software == "VASP":
        optional_params['potcar_path'] = potcar_path

    softwares = {"VASP": lambda params: Vasp().atomic_potential(**params)}

    program = softwares[software.upper()](optional_params)

    cut_numbers = parse_cut(cut)

    is_conduction = False
    if correction.upper() == "CONDUCTION":
        is_conduction = True

    for new_cut in cut_numbers:
        logger.info("Correcting POTFILE for cut = {:.3} ".format(new_cut))
        new_potential = program.correct_potential(new_cut, amplitude,
                                                  is_conduction)
        program.correct_file(new_potential, new_cut, amplitude)

    end_message()


def parse_cut(cut: str) -> list:
    """
    Parse cut in a list of numbers.

    Args:
        cut (str): Cut energy to be used in the program, it can be
                   passed in two ways:

                    unique value : float or integer
                    range:  begin(float|integer):pass(float|integer):end(float|integer)
    Returns:

        cut_numbers (list): Permited values of cut.
    """
    if not cut:
        raise ValueError('A valeu of cut energy must be provided.')

    cuts = cut.split(':')

    try:
        cut_number = [float(element) for element in cuts]
    except ValueError as bad_input:
        raise ValueError("Invalid Input.") from bad_input

    if len(cut_number) == 1:
        return cut_number
    elif len(cut_number) != 3:
        raise ValueError()

    return np.arange(cut_number[0],
                     cut_number[2],
                     cut_number[1],
                     dtype=np.float)
