"""
Interface for software correction modules
"""
from abc import ABC, abstractmethod
import numpy as np
from minushalf.atomic import InputFile
from minushalf.utils import (RYDBERG, BOHR_RADIUS, TRIMING_EXPONENT,
                             PRINCIPAL_SYMBOL_MAP, PI)


class Software(ABC):
    """
    Interface for implement occupation
    corrections of potential files of
    diverse softwares.
    """
    def __init__(self, cut: float, potfile_path, amplitude: float = 1.0):
        """
        Init for software
        """
        self.cut = cut
        self.amplitude = amplitude
        self.potfile_path = potfile_path
        self.k_max = 0.0
        self.fourier_coef = np.array([])
        self.corrected_fourier_coef = np.array([])
        self.radius = np.array([])
        self.potential_down_atom = np.array([])
        self.potential_down_ion = np.array([])
        self.occupation_potential = np.array([])
        self.resume_inp = ""

    @abstractmethod
    def write_new_potfile(self):
        """
        Writes corrected potential file.
        """

    @abstractmethod
    def parse_potfile(self):
        """
        Analyses useful informations in potential file.
        """

    def parse_inp(self):
        """
        Generate an resume of the INP_OCC file to be placed on
        the top of the potential file. The resume takes the following pattern:

        [principal_quantum_number][secondary_quantum_number][number_of_eletrons]
        """
        input_file = InputFile(input_path="./INP_OCC")

        resume_inp = []

        for orbital in input_file.valence_orbitals:

            aux = "{}{}{:.3}".format(orbital["n"],
                                     PRINCIPAL_SYMBOL_MAP[orbital["l"]],
                                     orbital["occupation"][0])
            resume_inp.append(aux)

        self.resume_inp = " ".join(resume_inp)

    def parse_vtotal(self):
        """
        Extract informations of the files VTOTAL.ae and
        VTOTAL_OCC. The following informations are extracted:

        radius: #TODO describe it

        potential_down_atom: #TODO: describe it

        potential_down_ion: #TODO: describe it

        """
        with open("VTOTAL.ae", "r") as vtotal, open("VTOTAL_OCC",
                                                    "r") as vtotal05:
            vtotal_lines = vtotal.readlines()
            vtotal05_lines = vtotal05.readlines()

            # Find radius
            initial_radius_index = 1
            final_radius_index = find_element(
                vtotal_lines, "Down potential follows (l on next line)",
                initial_radius_index)
            radius_lines = vtotal_lines[
                initial_radius_index:final_radius_index]

            self.radius = np.array(" ".join(radius_lines).split(),
                                   dtype=np.float)

            # Find atom and ion potentials
            initial_down_potential_index = final_radius_index + 2
            final_down_potential_index = find_element(
                vtotal_lines, "Up potential follows (l on next line)",
                initial_down_potential_index)
            potential_down_atom_lines = vtotal_lines[
                initial_down_potential_index:final_down_potential_index]
            potential_down_ion_lines = vtotal05_lines[
                initial_down_potential_index:final_down_potential_index]

            self.potential_down_atom = np.array(
                " ".join(potential_down_atom_lines).split(), dtype=np.float)

            self.potential_down_ion = np.array(
                " ".join(potential_down_ion_lines).split(), dtype=np.float)

    def trimming_function(self, atom_radius: float, ion_potential: float,
                          atom_potential) -> float:
        """
        Function that generate the potential for fractional occupation. The potential
        is cuted by a a function 0(r) to avoid divergence in calculations.
        The function of potential is defined as follows:

            V1/2 = (Vatom - Vion)*0(r), where 0(r) is;

                0(r) = A(1- (r/CUT)^n)^3 , for r <= CUT
                0(r) = 0, for r > CUT


        Args:
            cut (float): cut radius
            amplitude (float): factor for the function
        """
        if atom_radius >= self.cut:
            return 0

        return 4*PI*RYDBERG *\
            np.power(BOHR_RADIUS, 3) * np.power(1-np.power(atom_radius/self.cut, TRIMING_EXPONENT), 3) *\
            (ion_potential-atom_potential) * self.amplitude

    def set_occupation_potencial(self) -> None:
        """
        Returns the potential generated by fractional occupation.
        """
        vectorize_trimming = np.vectorize(self.trimming_function)
        self.occupation_potential = vectorize_trimming(
            self.radius, self.potential_down_ion, self.potential_down_atom)

    def fourier_transform(self, coefficient: float, k: float) -> float:
        r"""
        The pseudopotential is given in terms of the radial distance, and is only defined for r >= 0,
        as expected. Since it is only evaluated inside an integral from 0 to infinity, it does not
        matter what values it assumes for r < 0. A natural choice is to define the function to be
        zero for negative values, but a more convenient choice is to choose
        v(-r)=-v(r) and n(-r)=-n(r), since purely real and odd functions have purely imaginary Fourier transforms.
        Let v' and n' be the odd extensions of the potential and the number density, respectively.

             /\ inf          /\ inf                  /\ inf                   /\ inf
             |               |                       |                        |
        Ev = |  v(r)n(r)dr = |  v'(r)n'(r)dr = (1/2) |  v'(r)n'(r)dr = -(1/2) | V(k)N(k)dk
             |               |                       |                        |
            \/  0           \/  0                   \/ -inf                  \/ -inf
        On the third equalitty, we used the fact that the product of two odd
        functions is even, and in the last step we have applied Parseval's theorem,
        considering that the Fourier transforms are purely imaginary. Even though
        the function may not pass through the origin, we can still make an odd extension, by making it discontinuous.

        The data stored on POTCAR corresponds to the Fourier transform of the odd extension of v. It can be approximated
        by the summation on the right, where the prefactors were ommited.
                                                        ______
                            /\ inf                      \     | Nr
                            |                            \
        V(k) = i*sqrt(2/pi) |  v(r)sin(bkr)dr  => V(k) ~  >     (v[i]sin(bkr[i]) + v[i-1]sin(bkr[i-1]))/2 *(r[i]-r[i-1])
                            |                            /
                           \/ 0                         /_____| 1

        Computes the opposite of the imaginary part of the j-th fourier transform coefficient
        through numerical integrationIndex zero stands for the r=DeltaR, and the function is
        assumed to be zero at the origin. Thus, the first trapezium of the numerical integration is
        degenerated to a triangulum, and its area must be calculated as so.
        """
        if k == 0:
            k = 10**(-12)
        fourier_j = self.occupation_potential[0] *\
            np.sin(BOHR_RADIUS*k*self.radius[0])/2 * self.radius[0]

        filter_radius = self.radius[np.where(self.radius < self.cut)]

        radius = filter_radius[1:]
        past_radius = filter_radius[:-1]

        occupation_potential = self.occupation_potential[1:len(radius) + 1]
        past_occupation_potential = self.occupation_potential[:len(radius)]

        partial_coeff_calc = lambda rad, past_rad, occ_pot, past_occ_pot: (occ_pot*np.sin(BOHR_RADIUS*k*rad) +\
                                                                           past_occ_pot *\
                                                                           np.sin(BOHR_RADIUS*k*past_rad))/2 * (rad-past_rad)
        vectorize_function = np.vectorize(partial_coeff_calc)

        res = vectorize_function(radius, past_radius, occupation_potential,
                                 past_occupation_potential)

        return coefficient + (fourier_j + res.sum()) / (BOHR_RADIUS * k)

    def set_corrected_fourier_coef(self):
        """
        Generate corrected fourier coefficients to be placed on the potential file
        """
        all_k = np.arange(len(self.fourier_coef)) *\
            (self.k_max/len(self.fourier_coef))

        vectorize_fourier_transform = np.vectorize(self.fourier_transform)

        self.corrected_fourier_coef = vectorize_fourier_transform(
            self.fourier_coef, all_k)

    def correction(self):
        """
        Makes valence correction on potential file.
        """
        self.parse_vtotal()
        self.set_occupation_potencial()

        self.parse_inp()

        self.parse_potfile()
        self.set_corrected_fourier_coef()
        self.write_new_potfile()
